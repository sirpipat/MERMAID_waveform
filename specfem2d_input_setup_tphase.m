function outputdir = specfem2d_input_setup_tphase(name, bath, hydepth, water, freq, Par_file_base, outputdir, saveimage, branch, gpu_mode)
% outputdirs = SPECFEM2D_INPUT_SETUP_TPHASE(name, bath, hydepth, water, freq, Par_file_base, outputdir, saveimage, branch, gpu_mode)
% Generates Par_file, source file, and interface file for a fluid-solid
% simulation.
%
% INPUT:
% name              name for the model
% bath              bathymetry [X Z] where Z = f(X)
% hydepth           depth of the hydrophone
% water             sound speed profile of the water. Options are the followings:
%                       'homogenous'
%                       'Munk'          Munk sound speed profile
% freq              source frequency [Default: 10 Hz]
% Par_file_base     base Par_file to setting up Par_file 
%                   [Optional, Default: makeparams()]
% outputdir         directory for the input files
% saveimage         whether to save the snapshots of not [Default: true]
% branch            SPECFEM2D branch [Default: 'master']
%                   'master' (commit: e937ac2f74f23622f6ebbc8901d30fb33c1a2c38)
%                   'devel'  (commit: cf89366717d9435985ba852ef1d41a10cee97884)
% gpu_mode          whether to enable GPU MODE [Default: false]
%
% OUTPUT:
% outputdir         output directories for the fluid-solid simulation
%
% EXAMPLE:
% % you may replace this by 'demo1' to 'demo9'
% outputdir = specfem2d_input_setup_tphase('demo');
%
% SEE ALSO:
% SPECFEM2D_INPUT_SETUP, SPECFEM2D_INPUT_SETUP_FLAT, 
% SPECFEM2D_INPUT_SETUP_RESPONSE, RUNFLATSIM
%
% Last modified by sirawich-at-princeton.edu, 01/31/2024

defval('name', 'tphase')
defval('hydepth', 1500)
defval('water', 'homogeneous')
defval('freq', 10)
defval('saveimage', true)
defval('branch', 'devel')
defval('gpu_mode', true)
defval('bath', 'demo')

switch lower(bath)
    % just shelf and slope
    case 'demo'
        x = (0:100:1e6)';
        z = demobathymetry(x, 4000, 500, 40000, 25000);
        name = 'shelf_and_slope';
        bath = [x z];
    % generic seamount
    case 'demo1'
        x = (0:100:1e6)';
        z = demobathymetry(x, 4000, 200, 5000, 10000);
        name = 'seamount';
        bath = [x z];
    % smol hill
    case 'demo2'
        x = (0:100:1e6)';
        z = demobathymetry(x, 4000, 500, 40000, 25000);
        z = z - 1000 * exp(-(x-700000).^2/3e5);
        name = 'smol_hill';
        bath = [x z];
    % thin barrier
    case 'demo3'
        x = (0:100:1e6)';
        z = demobathymetry(x, 4000, 500, 40000, 25000);
        z = z - 3000 * exp(-(x-700000).^2/3e6);
        name = 'barrier';
        bath = [x z];
    % two thin barriers
    case 'demo4'
        x = (0:100:1e6)';
        z = demobathymetry(x, 4000, 500, 40000, 25000);
        z = z - 3000 * exp(-(x-400000).^2/3e6) - 3000 * exp(-(x-700000).^2/3e6);
        name = 'double_barriers';
        bath = [x z];
    % wide plateau
    case 'demo5'
        x = (0:100:1e6)';
        z = demobathymetry(x, 4000, 500, 40000, 25000);
        z = z - 2000 * exp(-(x-400000).^2/3e6) - 2000 * exp(-(x-700000).^2/3e6);
        z(and(x > 400000, x < 700000)) = 2000;
        name = 'plateau';
        bath = [x z];
    % wide barrier
    case 'demo6'
        x = (0:100:1e6)';
        z = demobathymetry(x, 4000, 500, 40000, 25000);
        z = z - 3000 * exp(-(x-700000).^2/1e10);
        name = 'barrier_wide';
        bath = [x z];
    % uneven ocean bottom
    case 'demo7'
        x = (0:100:1e6)';
        z = demobathymetry(x, 4000, 500, 40000, 25000);
        z(x > 100000) = z(x > 100000) - ...
            1000 * sin(2* pi * x(x > 100000) / 10000) .^ 2;
        name = 'uneven_bottom';
        bath = [x z];
    % trench
    case 'demo8'
        x = (0:100:1e6)';
        z = demobathymetry(x, 4000, 500, 40000, 25000);
        z = z + 4000 * exp(-(x-700000).^2/3e6);
        name = 'trench';
        bath = [x z];
    % deep basin
    case 'demo9'
        x = (0:100:1e6)';
        z = demobathymetry(x, 7000, 500, 40000, 25000);
        name = 'deep';
        bath = [x z];
    otherwise
        x = bath(:,1);
        z = bath(:,2);
end

% for meshing/running safety
z(z < 200) = 200;

% load baseline Par_file
if isempty(Par_file_base)
    params = makeparams();
else
    params = loadparfile(Par_file_base);
end

% create the DATA/ folder for the files generated by this function
system(sprintf('mkdir %s', outputdir));
system(sprintf('mkdir %sDATA/', outputdir));

% save input argument for future reproducibility
save(sprintf('%sDATA/input_arguments.mat', outputdir), ...
    'name', 'bath', 'hydepth', 'water', 'freq', 'Par_file_base', ...
    'outputdir', 'saveimage', 'branch', 'gpu_mode');

%% define models
% define material value
material1 = struct(...
    'model_number'      , 1         , ...
    'type_number'       , 1         , ...
    'type_name'         , 'elastic' , ...
    'rho'               , 2500      , ...
    'vp'                , 3400      , ...
    'vs'                , 1963      , ...
    'QKappa'            , 9999      , ...
    'Qmu'               , 9999        ...
);

material2 = struct(...
    'model_number'      , 2         , ...
    'type_number'       , 1         , ...
    'type_name'         , 'acoustic', ...
    'rho'               , 1020      , ...
    'vp'                , 1500      , ...
    'vs'                , 0         , ...
    'QKappa'            , 9999      , ...
    'Qmu'               , 9999        ...
);

% set models
params.nbmodels = 2;
params.MODELS = {material1, material2};

%% define geography of the problem

% set xlimit of the simulation
xmin = min(x);
xmax = max(x);
width = xmax - xmin;
elemsize = 500;
nx = width / elemsize;

% set interfaces
% bottom
itf1.npts = 2;
itf1.pts = [xmin 0; xmax 0];

% ocean bottom
itf2.npts = length(x);
itf2.pts = [x , 10000 - z];

% sea surface
zmax = 10000;
itf3.npts = 2;
itf3.pts = [xmin zmax; xmax zmax];

itfs = {itf1, itf2, itf3};
% set layers [crust ocean]
layers = [40 20];
nz = sum(layers);

% write interfaces file
% set parameters for internal meshing
params.interfacesfile = sprintf('interfaces_%s.dat', name);
writeinterfacefile(itfs, layers, sprintf('%sDATA/interfaces_%s.dat', outputdir, name));

params.read_external_mesh = false;
params.xmin = xmin;
params.xmax = xmax;
params.nx = nx;

% define regions
region1 = struct(...
    'nxmin'             , 1         , ...
    'nxmax'             , nx        , ...
    'nzmin'             , 1         , ...
    'nzmax'             , layers(1) , ...
    'material_number'   , 1           ...
);

region2 = struct(...
    'nxmin'             , 1         , ...
    'nxmax'             , nx        , ...
    'nzmin'             , layers(1) + 1  , ...
    'nzmax'             , nz        , ...
    'material_number'   , 2           ...
);

regions = {region1, region2};
params.nbregions = 2;
params.REGIONS = regions;

%% define water model
switch lower(water)
    case 'munk'
        water_model.name = 'Munk';
        water_model.epsilon = 0.00737;
        water_model.zc = 1300;
        water_model.zm = zmax - (min(z) - 500);
        water_model.dz = 10;
        water_model.B = 1300;
    otherwise
        water_model.name = 'homogeneous';
end

%% define SOURCE(s)
source = struct(...
    'source_surf'           , false     , ...   % inside the medium
    'xs'                    , 3000      , ...
    'zs'                    , 9000      , ...
    'source_type'           , 2         , ...   % moment tensor
    'time_function_type'    , 1         , ...   % Ricker
    'name_of_source_file'   , '""'      , ...   % blank for now
    'burst_band_width'      , 0         , ...
    'f0'                    , freq      , ...   % dominant frequency
    'tshift'                , 0         , ...
    'anglesource'           , 0         , ...
    'Mxx'                   , 1.0       , ...   % explosion
    'Mzz'                   , 1.0       , ...   % explosion
    'Mxz'                   , 0.0       , ...   % explosion
    'factor'                , 1e-9      , ...
    'vx'                    , 0.0       , ...
    'vz'                    , 0.0         ...
);
sources = {source};

params.NSOURCES = 1;

% write source file
writesource(sources, sprintf('%sDATA/SOURCE', outputdir), branch);

%% defeine set(s) of RECEIVER(s)
receiverset1 = struct(...
    'nrec'                              , 90     , ...
    'xdeb'                              , 100000 , ...
    'zdeb'                              , zmax - hydepth  , ...
    'xfin'                              , 990000 , ...
    'zfin'                              , zmax - hydepth  , ...
    'record_at_surface_same_vertical'   , false   ...
);

% 1-disp, 2 -veloc, 3-accel, 4-press, 5-curl of disp, 6-fluid poten
params.seismotype = [1 4];
receiversets = {receiverset1};
params.nreceiversets = 1;
params.RECEIVERS = receiversets;

% writes STATIONS file to include receiverset information when there are
% multiple receiversets.
params = writestations(params, sprintf('%sDATA/STATIONS', outputdir));
%% define other parameters
params.title = sprintf('fluid/solid interface : %s -- on %s branch', ...
    name, upper(branch));
params.time_stepping_scheme = 1;
params.NSTEP = 1000000;
params.DT = 1e-3;
params.subsamp_seismos = round(1 /params.DT / 20); % reduce to 20 Hz
params.NSTEP_BETWEEN_OUTPUT_SEISMOS = 20000;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
params.save_ASCII_seismograms = false;
params.save_binary_seismograms_single = false;
params.save_binary_seismograms_double = true;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
params.NTSTEP_BETWEEN_OUTPUT_ENERGY = 10000;
params.NSTEP_BETWEEN_OUTPUT_INFO = 10000;
params.NSTEP_BETWEEN_OUTPUT_IMAGES = 10000;
params.PML_BOUNDARY_CONDITIONS = false;
params.STACEY_ABSORBING_CONDITIONS = true;
params.GPU_MODE = gpu_mode;
params.factor_subsample_image = 0.025;
params.MODEL = 'default';
% do not save the images when SAVEIMAGE is set to false
params.output_color_image = saveimage;
params.output_postscript_snapshot = false; %saveimage;
%% write Par_file
% writeparfile(params, sprintf('%sDATA/Par_file_%s', outputdir_kk, name), branch);
writeparfile(params, sprintf('%sDATA/Par_file', outputdir), branch);
%% write a supplementary file for runthisexample.m
%  It is not used by specfem2d.
save(sprintf('%sDATA/supplementary_%s.mat', outputdir, name), 'water_model'); 
end

% z = DEMOBATHYMETRY(x, basindepth, shelfdepth, tipping, scaling)
% Create a sloped terrain to mimic the continental shelf and continental
% slope using a few parameters.
%
% INPUT:
% x                 horizontal position
% basindepth        depth of the basin below the sea level 
% shelfdepth        depth of the shelf below the sea level
% tipping           location of the end of the shelf
% scaling           length scale of the slope
%
% OUTPUT:
% z                 bathymetry elevation below the sea level
function z = demobathymetry(x, basindepth, shelfdepth, tipping, scaling)
defval('basindepth', 6000)
defval('shelfdepth', 1000)
defval('tipping', 40000)
defval('scaling', 25000)
% generates the Gaussian hill and fills the left side of the hill to have
% the same elevation of the peak
z = (shelfdepth - basindepth) * exp(-(x - tipping).^2/ scaling^2) ...
    + basindepth;
z(x < tipping) = shelfdepth;
end