function specfem2d_input_setup(name, topo, water, solid, source, angle, Par_file_base, outputdir)
% SPECFEM2D_INPUT_SETUP(name, topo, water, solid, source, angle, Par_file_base, outputdir)
%
% Generates Par_file, source file, and interface file for a fluid-solid
% simulation.
%
% INPUT:
% name              name for the model
% topo              topography end member. Options are the followings:
%                       'flat'          z = B
%                       'sloped'        z = A tanh(-(x - x0) / x1) + B
%                       'sinusoidal'    z = \sum (A sin(kx + c)) + B
%                       'parabolic'     z = A (x - x0)^2 + B
%                       'hill'          z = \sum (A exp(-(x - x0)^2 / x1^2)) + B
% water             sound speed profile of the water. Options are the followings:
%                       'homogenous'
%                       'Munk'          Munk sound speed profile
% solid             seismic structure of the solid. Options are the followings:
%                       'homogeneous'
%                       'layered'       2 layers with flat surface
% source            proximity of the source
%                       'shallow'
%                       'deep' -or- 'distant'
% angle             incident angle in degrees [Default: 0]
% Par_file_base     base Par_file to setting up Par_file
% outputdir         directory for the input files
%
% Last modified by Sirawich Pipatprathanporn, 07/21/2021

defval('topo', 'flat')
defval('water', 'homogeneous')
defval('solid', 'homogeneous')
defval('source', 'shallow')
defval('angle', 0)

% load baseline Par_file
if isempty(Par_file_base)
    params = makeparams();
else
    params = loadparfile(Par_file_base);
end

% create the DATA/ folder for the files generated by this function
system(sprintf('mkdir %s', outputdir));
system(sprintf('mkdir %sDATA/', outputdir));

%% define models
% define material value
material1 = struct(...
    'model_number'      , 1         , ...
    'type_number'       , 1         , ...
    'type_name'         , 'elastic' , ...
    'rho'               , 2500      , ...
    'vp'                , 3400      , ...
    'vs'                , 1963      , ...
    'QKappa'            , 9999      , ...
    'Qmu'               , 9999        ...
);

material2 = struct(...
    'model_number'      , 2         , ...
    'type_number'       , 1         , ...
    'type_name'         , 'acoustic', ...
    'rho'               , 1020      , ...
    'vp'                , 1500      , ...
    'vs'                , 0         , ...
    'QKappa'            , 9999      , ...
    'Qmu'               , 9999        ...
);

% set models
switch lower(solid)
    % TODO: add the second solid layer and
    case 'layered'
        params.nbmodels = 2;
        params.MODELS = {material1, material2};
    otherwise
        params.nbmodels = 2;
        params.MODELS = {material1, material2};
end

%% define geography of the problem

% set xlimit of the simulation
xmin = 0;
xmax = 20000;
width = xmax - xmin;
nx = width * 9 / 400; % mean element size is 44.44 m

% set interfaces
% bottom
itf1.npts = 2;
itf1.pts = [xmin 0; xmax 0];
% ocean bottom
itf2.npts = 401;
x = linspace(xmin, xmax, itf2.npts)';
switch lower(topo)
    case 'sloped'
        A = 4000 * random('unif', 0.9, 1.1);
        B = 4800 * random('unif', 0.9, 1.1);
        x0 = 5400 * random('unif', 0.9, 1.1);
        x1 = 1000 * random('unif', 0.9, 1.1);
        z = B + A * tanh(- (x - x0) / x1);
    case 'sinusoidal'
        N = unidrnd(3);
        A = unifrnd(0, 400, [1 N]);
        B = 4800 * random('unif', 0.9, 1.1);
        k = unifrnd(1/10000, 1/1000, [1 N]);
        c = unifrnd(0, 2*pi, [1 N]);
        z = B + sum(A .* sin(2 * pi * k .* x + c), 2);
    case 'parabolic'
        x0 = (xmin + xmax) / 2;
        A = 4000 * (1/(xmax - x0)^2) * random('unif', 0.2, 1);
        B = 4800 * random('unif', 0.9, 1.1);
        z = A * (x - x0) .^ 2 + B;
    case 'hill'
        N = unidrnd(3);
        A = unifrnd(0, 400, [1 N]);
        B = 4800 * random('unif', 0.9, 1.1);
        x0 = unifrnd(xmin, xmax, [1 N]);
        x1 = unifrnd(400, width/10, [1 N]);
        z = B + sum(A .* exp(- (x - x0) .^ 2 ./ (x1 .^ 2)), 2);
    otherwise
        z = 4800 * random('unif', 0.9, 1.1) * ones(size(x));
end
itf2.pts = [x , z];
% sea surface
zmax = 9600;
itf3.npts = 2;
itf3.pts = [xmin zmax; xmax zmax];

itfs = {itf1, itf2, itf3};

% set layers [crust ocean]
nz = zmax * 9 / 400;
layers = [nz/2 nz/2];

% write interfaces file
% set parameters for internal meshing
params.interfacesfile = sprintf('interfaces_%s.dat', name);
writeinterfacefile(itfs, layers, sprintf('%sDATA/interfaces_%s.dat', outputdir, name));

params.read_external_mesh = false;
params.xmin = xmin;
params.xmax = xmax;
params.nx = nx;

% define regions
region1 = struct(...
    'nxmin'             , 1         , ...
    'nxmax'             , nx        , ...
    'nzmin'             , 1         , ...
    'nzmax'             , nz/2      , ...
    'material_number'   , 1           ...
);

region2 = struct(...
    'nxmin'             , 1         , ...
    'nxmax'             , nx        , ...
    'nzmin'             , nz/2 + 1  , ...
    'nzmax'             , nz        , ...
    'material_number'   , 2           ...
);


regions = {region1, region2};

params.nbregions = 2;
params.REGIONS = regions;

%% define water model
switch lower(water)
    case 'munk'
        water_model.name = 'Munk';
        water_model.epsilon = 0.00737 * random('unif', 0.9, 1.1);
        water_model.zc = 1300 * random('unif', 0.5, 2);
        water_model.zm = zmax - (min(z) - 500);
        water_model.dz = 10;
        water_model.B = 1300 * random('unif', 0.5, 2);
    otherwise
        water_model.name = 'homogeneous';
end

%% define SOURCE(s)
% try on multiple sources
source1 = struct(...
    'source_surf'           , false     , ...   % inside the medium
    'xs'                    , 500      , ...
    'zs'                    , 720       , ...
    'source_type'           , 2         , ...   % moment tensor
    'time_function_type'    , 1         , ...   % Ricker
    'name_of_source_file'   , '""'      , ...   % blank for now
    'burst_band_width'      , 0         , ...
    'f0'                    , 10        , ...   % dominant frequency
    'tshift'                , 0         , ...
    'anglesource'           , 0         , ...
    'Mxx'                   , 1.0       , ...   % explosion
    'Mzz'                   , 1.0       , ...   % explosion
    'Mxz'                   , 0.0       , ...   % explosion
    'factor'                , 1e-9        ...
);

sources{1} = source1;
for ii = 1:38
    source = source1;
    source.xs = 500 + ii * 500;
    source.tshift = 0 + ii * 500 * sin(angle * pi / 180) / 3400;
    sources{ii+1} = source;
end


%sources = {source1, source2, source3, source4, source5, source6, source7};
    
params.NSOURCES = length(sources);

% write source file
writesource(sources, sprintf('%sDATA/SOURCE_%s', outputdir, name));

%% defeine set(s) of RECEIVER(s)
receiverset1 = struct(...
    'nrec'                              , 30    , ...
    'xdeb'                              , 15000 , ...
    'zdeb'                              , 4950  , ...
    'xfin'                              , 15000 , ...
    'zfin'                              , 9450  , ...
    'record_at_surface_same_vertical'   , false   ...
);

receiverset2 = struct(...
    'nrec'                              , 30    , ...
    'xdeb'                              , 5000  , ...
    'zdeb'                              , 8100  , ...
    'xfin'                              , 19500 , ...
    'zfin'                              , 8100  , ...
    'record_at_surface_same_vertical'   , false   ...
);

receiversets = {receiverset1, receiverset2};

params.seismotype = 4;
params.nreceiversets = 2;
params.RECEIVERS = receiversets;

%% define other parameters
params.title = sprintf('fluid/solid interface : %s', name);
params.time_stepping_scheme = 1;
params.NSTEP = 20000;
params.DT = 5e-4;
%% write Par_file
writeparfile(params, sprintf('%sDATA/Par_file_%s', outputdir, name));
%% write a supplementary file for runthisexample.m
%  It is not used by specfem2d.
save(sprintf('%sDATA/supplementary_%s.mat', outputdir, name), 'water_model');
end

% ocean bottom is modeled as a modified logistic function
% add more parameters for 4800, 4000 etc. or even random parameters
function z = func(x)
z = 4800 + 4000 * (1 ./ (1 + exp((x-5400)/1000)));
end